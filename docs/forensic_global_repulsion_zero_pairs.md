# Forensic scan: why XPBD global repulsion reports zero

## A) Expected call path
- `runPhysicsTick` chooses the XPBD branch whenever `engine.config.useXPBD` is true (`src/physics/engine/engineTick.ts:1016-1024`), so the rest of the analysis assumes that path is exercised.
- `runPhysicsTickXPBD` (`src/physics/engine/engineTickXPBD.ts:462-693`) executes preflight, constraint rebuild, motion policy creation and drag velocity (`src/physics/engine/engineTickXPBD.ts:462-565`), then hits the documented repulsion seam (`src/physics/engine/engineTickXPBD.ts:566-641`).
- At that seam the intended order is `applyRepulsion ? integrateNodes ? applyKinematicDrag ? solveXPBDEdgeConstraints ? reconcileAfterXPBDConstraints`, concretely `integrateNodes` is invoked at `src/physics/engine/engineTickXPBD.ts:643-660`, `applyKinematicDrag` immediately follows at `src/physics/engine/engineTickXPBD.ts:656-661`, `solveXPBDEdgeConstraints` runs at `src/physics/engine/engineTickXPBD.ts:679`, and `reconcileAfterXPBDConstraints` at `src/physics/engine/engineTickXPBD.ts:692-693`.
- The `integrateNodes` implementation (`src/physics/engine/integration.ts:118-214`) reads every node’s `fx/fy` to compute acceleration before updating velocities/positions, so the seam guarantees forces produced by `applyRepulsion` reach the integrator before XPBD corrections run.

## B) Actual runtime call proof (no HUD)
1. **Repulsion never executes unless the toggle is explicitly true.** The only call site in the XPBD tick lives inside `if (engine.config.xpbdRepulsionEnabled) { ... }` (`src/physics/engine/engineTickXPBD.ts:576-641`), so the method is skipped whenever the toggle is falsy. The property exists on `ForceConfig` with the note “Default: false” (`src/physics/types.ts:259`), and `DEFAULT_PHYSICS_CONFIG` never populates it (`src/physics/config.ts:1-165`), meaning no repulsion code runs by default.
2. **XPBD repulsion cannot even start unless XPBD mode is active.** `runPhysicsTick` dispatches to `runPhysicsTickXPBD` only when `engine.config.useXPBD` is true (`src/physics/engine/engineTick.ts:1016-1024`), so turning XPBD off bypasses the entire seam and leaves `node.fx/fy` untouched by this path.
3. **Eligible pairs can still be zero because the loop only iterates awake dots.** XPBD builds `activeNodes`/`sleepingNodes` from `node.isSleeping` (`src/physics/engine/engineTickXPBD.ts:586-601`), and `applyRepulsion` only loops over `activeNodes` plus sleeping pairs (`src/physics/forces.ts:282-289`). If every dot carried `isSleeping=true` (set inside `src/physics/engine/integration.ts:218-226` when velocity/force are low), `activeNodes` is empty and the `for (let i = 0; i < activeNodes.length; i++)` body never runs, yielding zero eligible pairs even though the code path is live.
4. **Forces are not wiped between `applyRepulsion` and `integrateNodes`.** The only `node.fx = 0` inside the toss is the manual clear right before the repulsion call (`src/physics/engine/engineTickXPBD.ts:576-583`); there are no further writes before `integrateNodes` consumes the values at `src/physics/engine/integration.ts:118-214`, so the repulsion contributions persist.
5. **`integrateNodes` does use `fx/fy` even under XPBD.** The loop reads `node.fx/fy`, stores `node.prevFx/Fy`, and computes `ax = node.fx / effectiveMass` before updating velocities (`src/physics/engine/integration.ts:118-158`), so the XPBD integrator honours the forces written at the seam.

## C) “Single kill switch” hypotheses
1. `engine.config.xpbdRepulsionEnabled` (defined in `ForceConfig`, see `src/physics/types.ts:259`) gates the entire block in `src/physics/engine/engineTickXPBD.ts:576-641`. Any falsy value (the current default) makes the seam a no-op, producing zero pairs. Confirm by setting the flag true in a custom config or forcing it before the tick and watching for `debugStats.safety.xpbdRepulsionPairsChecked` > 0.
2. `engine.config.useXPBD` at `src/physics/engine/engineTick.ts:1016-1024` determines whether XPBD mode—and therefore the repulsion seam—is ever entered. Value `false` removes the tick entirely; value `true` is required to exercise the new force pass. Validate by toggling it and logging `debugStats?.mode` (the XPBD tick sets it to `'XPBD'`).
3. Every dot’s `isSleeping` flag is enforced in `integration.ts:218-226` and consumed when the seam builds `activeNodes` at `src/physics/engine/engineTickXPBD.ts:586-601`. If every dot is sleeping, `activeNodes.length === 0` and the pairwise loop in `src/physics/forces.ts:282-289` never runs. Re-awaken a couple of dots before the seam (clear `isSleeping`/`sleepFrames`) and observe `stats.safety.repulsionPairsChecked` or another `debugStats` field start reporting activity to prove this gate.

## D) Minimal fix plan (not implemented)
- Enable the seam by default: add `xpbdRepulsionEnabled: true` to `DEFAULT_PHYSICS_CONFIG` (`src/physics/config.ts:1-165`) so `engineTickXPBD.ts:576-641` executes when XPBD mode runs, then monitor `debugStats.safety.xpbdRepulsionPairsChecked` to make sure the branch is alive (the stats fields are already zeroed in `engineTickHud.ts:106-110`).
