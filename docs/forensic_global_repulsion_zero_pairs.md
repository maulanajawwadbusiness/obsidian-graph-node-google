# Forensic scan: why XPBD global repulsion reports zero

## A) Expected call path
1. `runPhysicsTick` flips between the legacy path and the XPBD path based on `engine.config.useXPBD` (`src/physics/engine/engineTick.ts:1016-1024`). The XPBD branch is the only place that ever touches `runPhysicsTickXPBD`, so we assume it is active for the rest of the trace.
2. `runPhysicsTickXPBD` (`src/physics/engine/engineTickXPBD.ts:462-693`) builds the node list, runs preflight/firewall checks, rebuilds constraints if dirty, and accumulates edge telemetry before evaluating the time policy and motion policy (`engineTickXPBD.ts:462-565`). The drag velocity pass (`applyDragVelocity` at `engineTickXPBD.ts:562-564`) happens before the force seam.
3. The XPBD force seam is explicitly documented in the code as the only safe place to write forces (`engineTickXPBD.ts:566-641`). The intended order is `applyRepulsion`, then `integrateNodes`, then `applyKinematicDrag`, then `solveXPBDEdgeConstraints`, and finally `reconcileAfterXPBDConstraints`. The implementation matches the comments: the repulsion block runs just before `integrateNodes` (`engineTickXPBD.ts:643-660`), the drag snap runs immediately afterward (`engineTickXPBD.ts:656-661`), the solver runs at `engineTickXPBD.ts:679`, and reconcile runs at `engineTickXPBD.ts:692-693`.
4. `integrateNodes` (`src/physics/engine/integration.ts:118-214`) reads `node.fx`/`node.fy` for every node, computes acceleration (`ax = fx / mass`), applies base integration (`applyBaseIntegration`), damping, optional carrier flow/hub velocity scaling (disabled in XPBD because `useXPBD` is true), clamps velocity, and finally increments `node.x`/`node.y`. Because the XPBD path reuses this integrator, any forces written at the seam must reach the integrator before the XPBD solver touches positions.

## B) Actual runtime call proof (no HUD)
1. **The block never runs when `xpbdRepulsionEnabled` is false.** The repulsion code is entirely guarded by `if (engine.config.xpbdRepulsionEnabled)` (`engineTickXPBD.ts:576-641`). `xpbdRepulsionEnabled` is defined in `ForceConfig` with the comment “Default: false” (`src/physics/types.ts:259`), but `DEFAULT_PHYSICS_CONFIG` (`src/physics/config.ts:1-165`) never populates it, so the XPBD seam is a no-op in the shipped configuration.
2. **Only XPBD mode executes the seam at all.** `runPhysicsTick` dispatches to `runPhysicsTickXPBD` only when `engine.config.useXPBD` is true (`engineTick.ts:1016-1024`). If that flag is false, none of the XPBD-only code—including the repulsion seam—runs, and the graph stays on the legacy tick where repulsion lives in `engineTick.ts` via `applyForcePass` instead.
3. **Sleeping gating can drive `activeNodes` to zero.** Right before calling `applyRepulsion`, the XPBD tick splits nodes into `activeNodes` vs `sleepingNodes` based on `node.isSleeping` (`engineTickXPBD.ts:586-601`). `integration.ts` sets `isSleeping = true` whenever velocity, force, and pressure thresholds remain below the configured sleep caps (`integration.ts:218-226`). If each node is sleeping, the loop `for (let i = 0; i < activeNodes.length; i++)` in `applyRepulsion` (`forces.ts:282-289`) never executes, so zero pairs are checked even though the code path was executed.
4. **Pairstride sampling can skip all pairs in practice.** The XPBD block computes a deterministic `pairStride` (1–4) based on node count and drag state (`engineTickXPBD.ts:604-623`). `applyRepulsion` uses `shouldSkipPair` (`forces.ts:52-65`) to skip any pair whose mixed index modulo stride is non-zero. For large graphs the stride reaches 4, so only 25% of pairs are evaluated; combine that with `activeNodes.length` being zero or very small and the repulsion pairs counters stay at zero.
5. **`stats.safety.xpbdRepulsion*` fields remain zero when the block never runs.** The HUD resets these counters every tick (`engineTickHud.ts:106-110`), and `applyRepulsion` writes to them only when it executes (`forces.ts:244-274`). If the XPBD block is skipped, the debug stats never step outside zeros, which matches the observed “0 repulsion” behavior even though the XPBD solver is running.
6. **`node.fx` survives the seam into integration.** The only force zeroing before `integrateNodes` is the manual `node.fx = 0; node.fy = 0;` loop right before `applyRepulsion` (`engineTickXPBD.ts:576-583`). Nothing clears the forces between the XPBD block and `integrateNodes` (`integration.ts:118-214`), so if `applyRepulsion` does run it will contribute to `integrateNodes`’ acceleration calculation. This eliminates the hypothesis that another pass wipes the forces before integration.

## C) “Single kill switch” hypotheses that explain “0 repulsion on-screen”
1. `engine.config.xpbdRepulsionEnabled` (`src/physics/types.ts:259`) gates the entire XPBD repulsion block (`engineTickXPBD.ts:576-641`). Defaulting it to `false` in `DEFAULT_PHYSICS_CONFIG` means the seam is effectively disabled. To confirm, temporarily set this flag to `true` (e.g., in a developer config or by mocking `engine.config`) and verify that `debugStats.safety.xpbdRepulsionPairsChecked` increments when a frame runs.
2. `engine.config.useXPBD` (`engineTick.ts:1016-1024`) decides whether `runPhysicsTickXPBD` runs at all. With XPBD disabled the legacy tick is used and the seam can never run. Flip the flag at runtime and log `debugStats?.mode` (set to `'XPBD'` inside `runPhysicsTickXPBD`) to prove which tick executed.
3. All nodes being flagged as sleeping disables pair creation. The XPBD split uses `node.isSleeping` (`engineTickXPBD.ts:586-601`), and integration sets that flag when speed, force, and pressure stay below thresholds (`integration.ts:218-226`). If the graph has settled and every node is sleeping, `activeNodes` is empty and the `for` loops in `applyRepulsion` (`forces.ts:282-289`) never start, leaving repulsion pairs checked at zero. Clearing `node.isSleeping` / `node.sleepFrames` before the seam and observing `stats.safety.repulsionPairsChecked` begin rising proves this hypothesis with no UI work.

## D) Minimal fix plan (not implemented)
- Enable the seam by default so the diagnostics always run: set `xpbdRepulsionEnabled: true` inside `DEFAULT_PHYSICS_CONFIG` (`src/physics/config.ts:1-165`). With XPBD enabled the block at `engineTickXPBD.ts:576-641` will execute every tick, and the two telemetry fields that already exist (`engineTickHud.ts:106-110`) provide proof the branch is alive. If necessary, pair the change with instrumentation that logs `debugStats.safety.xpbdRepulsionPairsChecked`/`repulsionPairsApplied` to verify the block is generating non-zero values.
